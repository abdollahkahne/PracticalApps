@page "/chat"
@using Microsoft.AspNetCore.SignalR.Client
@using Utilities
@inject NavigationManager _navigationManager
@inject ILoggerProvider _loggerProvider
@implements IAsyncDisposable

<PageTitle>Chat</PageTitle>
<h3>chat</h3>
<Dialog Title="This is a component sample" @ref="_dialog">
    <p>we can add the children as many as we can <i>have more than one html tag in parallel here</i></p>
</Dialog>
<div class="form">
    <div class="form-group">
        <label for="username">User</label>
        <input type="text" class="form-control" name="username" id="username" @bind="username">
    </div>
    <div class="form-group">
        <label for="message">Message</label>
        <textarea class="form-control" name="message" id="message" cols="18" rows="3" @bind="message"></textarea>
    </div>
    <button class="btn btn-primary" disabled="@(sendButtonEnabled==false)" @onclick="sendMessage">Send</button>
</div>

<div id="messages-list">
    <ul style="list-style: none;">
        @foreach (var item in _messages)
        {
            <li>@item</li>
        }
    </ul>
</div>


@code {
    private Dialog? _dialog; //ref
    private string? message { get; set; }
    private string? username { get; set; }
    private HubConnection? hubConnection { get; set; }
    private readonly List<string> _messages = new();
    private bool sendButtonEnabled = false;

    protected override void OnParametersSet()
    {
        // log Dialog Component just to see a component
        Console.WriteLine(_dialog?.ChildContent);
    }

    protected async override Task OnInitializedAsync()
    {
        // In SignalR and wasm prerendering occurs before the client connection to the server is established.

        hubConnection = new HubConnectionBuilder()
        .WithUrl(_navigationManager.ToAbsoluteUri("/chathub"), options =>
        {
            // we added a wrapper around the default http handler
            options.HttpMessageHandlerFactory = innerHandler => new IncludeRequestCredentialsMessageHandler
            { InnerHandler = innerHandler };
            @* // The above option config only runs for http request and not web sockets *@
            @* options.Transports = Microsoft.AspNetCore.Http.Connections.HttpTransportType.LongPolling; *@
        })
.ConfigureLogging(logging => logging.AddProvider(_loggerProvider))
.Build(); // _navigation manager is a service which provide work
        @* with links(like Url in MVC and Razor almost) *@
        // since this is component and it may be use anywhere we should use its url in absolute form
        hubConnection.On<string, string>("ReceiveMessage", (msg, user) =>
        {

            @* since here in this callbacl this is captured by callback we can use it to change or call methods at the component
                itself *@
            var encodedMsg = $"{user}: {msg}";
            _messages.Add(encodedMsg);
            @* this.username = string.Empty; *@
            @* Does this is necessary? Yes, to call the field and properties from outside scope we
                should use this keyword.And without that they are not set to empty value. But they should get empty in sending method
                not in callbak logically:|*@
            @* this.message = string.Empty; *@
            StateHasChanged();
            @* Components ReRendered! This is required since the callback does not call directly using Blazor event trigger
                for example @bind or @onclick. Even altough we change this component properties here in callback,
                we should call it *@
        });
        hubConnection.Reconnecting += (error) => { this.sendButtonEnabled = false; return Task.CompletedTask; };
        hubConnection.Reconnected += (connectionId) => { this.sendButtonEnabled = true; return Task.CompletedTask; };
        hubConnection.Closed += async (error) =>
        {
            if (error != null)
            {
                this.sendButtonEnabled = false;
                await Task.Delay(5000);
                await this.hubConnection.StartAsync();
            }

        };
        if (hubConnection.State == HubConnectionState.Disconnected)
        {
            await hubConnection.StartAsync();
        }
        if (hubConnection.State == HubConnectionState.Connected)
        {
            sendButtonEnabled = true;
        }
        await base.OnInitializedAsync();

    }

    private async Task sendMessage()
    {
        if (hubConnection != null)
        {
            sendButtonEnabled = false;
            await hubConnection.SendAsync("SendMessage", username, message);
            username = string.Empty;
            message = string.Empty;
            sendButtonEnabled = true;
        }
    }

    public async ValueTask DisposeAsync()
    @* we should dispose if we have any disposable item. implement IDisposable and
        IAsyncDisposable in this component using @implements IDisposable for example *@
    {
        try
        {
            #region
#nullable disable
            await hubConnection.DisposeAsync();
            #endregion
        }
        catch (System.Exception ex)
        {

            Console.WriteLine(ex.Message);
        }
    }

}


@*

    Unlike Razor Pages and MVC, which are built around a request/response model, components are used specifically for
    client-side UI logic and composition. So I think, they only instantiated once in bootstrap phase?? (May be initiallized
    completely when required! for example in case of conditional rendering) and reused multiple
    time everywhere they used in pages which specified by Url and handled by index.html or as a component in another page
    which handled by index.html. it has no pipeline and no access to request/response pipeline (index has access in the
    refreshing a page or link)
    Components render into an in-memory representation of the browser's Document Object Model (DOM) called a render tree,
    which is used to update the UI in a flexible and efficient way.
    hosting Razor components on the server or Client? The response make two Framework:
    1- Host Razor Component in Server => Blazor Server
    2- Host Razor Component in Client => Blazor Web Assembly

    Blazor WebAssembly is single thread since it runs in browser and Blazor Server try to emulate that behaviour using a
    synchronization context (SynchronizationContext). A component's lifecycle methods and event callbacks raised by Blazor
    are executed on the synchronization context. At any given point in time, work is performed on exactly one thread, which
    yields the impression of a single logical thread. No two operations execute concurrently. So we should consider
    followings:
    1- Avoid thread-blocking calls: Do not use Wait, WaitAny, WaitAll, Sleep, Result, GetResut in components.
    2- Where an event external to a component wants to update the state of component (For example consider case of timer or
    notification services), use InvokeAsync method of ComponentBase class. This method dispatches code execution to Blazor's
    synchronization context (See Notifications example)

    Blazor Server:
    Razor Component hosted in Server so UI updates, event handling and JavaScript Calls are handled over a SignalR
    connection. in this case signalR work in both side as following:
    1- From Server to client: Sending UI for first time (Apparantly this prerendered using html and _Host.cshtml razor page
    in the first opening page from addressbar)
    2- From Client to Server: Sending UI Events. Clicking a new url in the app is event if we use Router Component in our
    App here and no new connection opens here
    3- From Server to Client: Applying the Updates to Rendered Component

    The state on the server associated with each connected client is called a circuit. A circuit can tolerate temporary
    network interruptions and attempts by the client to reconnect to the server when the connection is lost.
    In a Blazor Server app, each browser screen requires a separate circuit and separate instances of server-managed
    component state (While in mvc all Tabs in the browser and even iframes consider on connection an can use for example the
    cookie and auth sessions). Gracefull
    Blazor considers closing a browser tab or navigating to an external URL a graceful termination. In the event of a
    graceful termination, the circuit and associated resources are immediately released. A client may also disconnect
    non-gracefully, for instance due to a network interruption. Blazor Server stores disconnected circuits for a
    configurable interval to allow the client to reconnect.
    On the client, the Blazor script (blazor.server.js) establishes the SignalR connection with the server. The script is
    served to the client-side app from an embedded resource in the ASP.NET Core shared framework (Not the wwwroot folder).
    The client-side app is responsible for persisting and restoring app state as required.
    In this case we have a router system that sets up client-side routing using the Router component. The
    Router component intercepts browser navigation and renders the page that matches the requested address. This uses
    signalR.

    Blazor Web Assembly:
    * APIs that aren't applicable inside of a web browser (for example, accessing the file system, opening a socket, and
    threading) throw a PlatformNotSupportedException.
    * For apps that require third-party JavaScript libraries and access to browser APIs, components interoperate with
    JavaScript. Components are capable of using any library or API that JavaScript is able to use.
    * The Blazor WebAssembly runtime uses JavaScript interop to handle DOM manipulation and browser API calls

    Blazor WebAssembly apps run client-side in the browser on a WebAssembly-based .NET runtime. The Blazor app, its
    dependencies, and the .NET runtime are downloaded to the browser. The app is executed directly on the browser UI thread.
    UI updates and event handling occur within the same process. The app's assets are deployed as static files to a web
    server or service capable of serving static content to clients (So it does not need necessarily a .Net Backend! and can
    be serve from CDN and cloud services like AWS,Azure and Firebases).
    When the Blazor WebAssembly app is created for deployment without a backend ASP.NET Core app to serve its files, the app
    is called a standalone Blazor WebAssembly app. When the app is created for deployment with a backend app to serve its
    files, the app is called a hosted Blazor WebAssembly app.
    Using hosted Blazor WebAssembly, you get a full-stack web development experience with .NET, including the ability to
    share code between the client and server apps, support for prerendering, and integration with MVC and Razor Pages. A
    hosted client app can interact with its backend server app over the network using a variety of messaging frameworks and
    protocols, such as web API, gRPC-web, and SignalR.
    The blazor.webassembly.js script is provided by the framework and handles:
    * Downloading the .NET runtime, the app, and the app's dependencies.
    * Initialization of the runtime to run the app.

    Browser compatibility analyzer for Blazor WebAssembly
    Blazor WebAssembly apps target the full .NET API surface area, but not all .NET APIs are supported on WebAssembly due to
    browser sandbox constraints. Unsupported APIs throw PlatformNotSupportedException when running on WebAssembly. A
    platform compatibility analyzer warns the developer when the app uses APIs that aren't supported by the app's target
    platforms. For Blazor WebAssembly apps, this means checking that APIs are supported in browsers.
    Blazor WebAssembly and RCL projects automatically enable browser compatibility checks by adding browser as a supported
    platform with the SupportedPlatform MSBuild item. Library developers can manually add the SupportedPlatform item to a
    library's project file to enable the feature:
    <ItemGroup>
    <SupportedPlatform Include="browser" />
    </ItemGroup>
    You can also make a an api Unsupported in our APIs using the UnsupportedOSPlattformAttribute. for example:
    using System.Runtime.Versioning;
    [UnsupportedOSPlatform("browser")]
    private static string GetLoggingDirectory()
    {
    ...
    }



    Razor Components and App:
    Regardless of the hosting model, the app and component models are the same.
    App.razor is the razor app and other .razor exist in Pages Or Shared Folders are razor components.

    How Routing Happens?
    When a Razor component (.razor) with an @page directive is compiled, the generated component class is provided a
    RouteAttribute specifying the component's route template. (So every Razor Component Convert to a class).
    Handling of them happens in runtime by App.razor using Router component :

    1- When the app starts, the assembly specified as the Router's AppAssembly is scanned to gather route information for
    the app's components that have a RouteAttribute. A component can have zero to multiple @page directive for this purpose
    and even like API Controller we can add a base url to index.html/_Host.cshtml header as <base href="/" />. We can add
    more than one Assembly to scanned here using AdditionalAssemblies="new[] { typeof(Component1).Assembly }">. We can pass
    route parameter similar ro mvc in route templates. for example see RouteParameter.razor. We can pass parameter from
    query string too. to see them see QuerystringSample.razor component

    2- When a route requested by user in the context of blazor (for example by Clicking in NavLink in a component and not
    through address bar), RouteView Component Used to Receives the RouteData from the Router along with any route parameters
    and Renders the specified component with its layout, including any further nested layouts.

    we can alternatively use LayoutView arround the components or RouteView to apply it and we should feed route view in
    some way to its content. Optional layout can be feed to component
    directly using @layout directive too. Layout is a component which inherit from
    LayoutComponentBase and receive the content through body property @body (LayoutComponentBase.body)

    Using dot in Route Parameter:
    For hosted Blazor WebAssembly and Blazor Server apps, the server-side default route template assumes that if the last
    segment of a request URL contains a dot (.) that a file is requested. if we may have route paramter with dot we should
    add them explicitly using fallback. For example:
    app.MapFallbackToFile("/example1/{param?}","index.html"); //for wasm
    app.MapFallbackToPage("/example/{param?}","/_Host"); //for blazor server
    since routing data calculate in fallback time so we can use them as route parameter

    Catch All route
    We may have positions when route parameter may have slash (/) in some cases like /blogs/products/a/b/c/d
    to catch this type of url we can use catch all template which has an star in route parameter definition in template and
    always cast as string and only at the end of url. for example consider this:
    /blogs/{*productRoute};
    /blog/this/is/a/sample is an acceptable url which have productRoute=this/is/a/sample

    NavigationManager
    This is a service which is similar to URL Helpers in MVC and the pattern is to use them as injected service instances.
    it has multiple application which is useful for client side scenarios:
    1- Push to another page in client side using history API of browser
    2- Handle leaving the page in client side
    3- Has properties to get absolute and relative uri/urls regarding base defined as meta in index.html
    You can see an example in RouteParameter.razor component for that

    Query String Parameter
    They are Parameters which have [SupplyParameterFromQuery] attribute and [Parameter] too and they do not insert in route
    templates. We can also have different query string name than Parameter name (for example for keywords in c# like var) as
    [SupplyParameterFromQuery(Name="var")],
    We can get add/remove query string using NavigationManager instance as below:
    _navigationManager.GetUriWithQueryParameter("{NAME}", {VALUE})
    Component parameters can only receive query parameter values in routable components with an @page directive.

    Configuration:
    Blazor WebAssembly loads configuration from the following app settings files by default:
    * wwwroot/appsettings.json.
    * wwwroot/appsettings.{ENVIRONMENT}.json, where the {ENVIRONMENT} placeholder is the app's runtime environment.
    (As it see they are placed in wwwroot since they should be available in client so Configuration and settings files in a
    Blazor WebAssembly app are visible to users. Don't store app secrets, credentials, or any other sensitive data in the
    configuration or files of a Blazor WebAssembly app. Some provider like Azure and Azure Key vault configuration provider
    needs this so avoid using them!)

    Configuration in app settings files are loaded by default. Inject an IConfiguration instance into a component to access
    the configuration data.
    WebAssemblyHostConfiguration is saved in builder.Configuration and can be added by following methods like
    Add, AddJsonFile,... and can be read using [] and GetSection and can be availabe to component from IConfiguration
    service injection
    Configuration are cached so in case of PWA they are not update until the next build and deploy of app by rebuilding
    PWA's service-worker.js and service-worker-assets.js files

    Dependency Injection in Blazor
    It is similar to rest of ASP.NET. They are availabe as:
    * Framework-registered services can be injected directly into components of Blazor apps (For example NavigationManager).
    * Blazor apps define and register custom services and make them available throughout the app via DI.

    some useful services in blazor are:
    1- HttpClient: Provides methods for sending HTTP requests and receiving HTTP responses from a resource identified by a
    URI.
    * Scoped and not singleton: in MVC the pattern is to inject the HttpClient Factory singleton and then generate
    HttpClient in every usage but here since it is runned in browser it registered as Scoped here.
    * The instance of HttpClient in a Blazor WebAssembly app uses the browser for handling the HTTP traffic in the
    background
    * Blazor Server apps don't include an HttpClient configured as a service by default. Provide an HttpClient to a Blazor
    Server app.
    2- NavigationManager: Contains helpers for working with URIs and navigation state. This is injected as Singleton in wasm
    blazor and Scoped in blazor server
    3- IJSRuntime: this is used for calling JS function from .NET (It is a js runtime where js function dispatched). It is
    register as Singleton in blazor wasm and register as scoped in Blazor server.

    We can register other custom service and inject them too and similar to Rest of ASP for use of the above services we
    should inject them through Constructor.
    Blazor WebAssembly apps don't currently have a concept of DI scopes. Scoped-registered services behave like Singleton
    services. Has it the concept of lifetime? since it has not classical concept of requests and response pipeline.
    The case are true for some of Blazor App but not for all of it where we have Asp.Net MVC, Web API or Razor Pages.
    Scoped services aren't reconstructed when navigating among components on the client, where the communication to the
    server takes place over the SignalR connection of the user's circuit, not via HTTP requests. But in cases where request
    should pass the pipeline from server to reach the blazor server, it reconstruct the Scoped Services too. For example:
    * The user closes the browser's window. The user opens a new window and navigates back to the app.
    * The user closes the last tab of the app in a browser window. The user opens a new tab and navigates back to the app.
    * The user selects the browser's reload/refresh button
    In all of these cases, the user state does not preserve unless you persist it.

    After services are added to the service collection, inject the services into the components using the @inject Razor
    directive, which has two parameters:
    1- Type: The type of the service to inject.
    2- Property: The name of the property receiving the injected app service. The property doesn't require manual creation.
    The compiler creates the property.

    Internally this razor component convert to a class which has a property with an [Inject] attribute. To use similar
    pattern first create a base class and then use the injected service as property using [Inject] property on that base
    class. Altough from best practice view, in the classes it is good to inject services from Constructor. Then to inherit
    base class use @inherits directive in razor component. [Inject] is only availabe in classes which implements from
    IComponent interface.
    In Blazor Server, scope is from start of socket request till the end of it, so scoped last longer.
    In Blazor WebAssembly, Scope is not have meaning since it handled in client side and there, there is not no request or
    response in classic form, so scoped service are singleton.
    Consider we have the following requirement for a service (Singleton in Component):
    1- Should be reused within a component, as the transient lifetime is inappropriate.
    2- Shouldn't be shared across components, as the singleton lifetime is inappropriate.

    In this situation we can use a OwningComponentBase component which can create a singleton service in for just that
    component. OwningComponentBase is an abstract type derived from ComponentBase that creates a DI scope corresponding to
    the lifetime of the component. When the component is destroyed, services from the component's scoped service provider
    are disposed as well.

    Transient Services in Blazor
    Classes implementing IDisposable should not be registered as Transient unless using components that own their own Scope,
    and you know exactly what you are doing. Only register classes as Transient dependencies if they DO NOT implement
    IDisposable, otherwise, your application will leak memory. In this cases we should use the OwningComponentBase to
    dispose them when the component destroyed.

    JS Initializer
    Consider the following situation in client side:
    * We want to initialize some libraries before blazor app Startup
    * We want to add configuration to blazor
    * We want to customize how blazor app loads

    In this cases JS Initializer are useful which execute logic before and after a Blazor app loads.
    JS initializers are detected as part of the build process and imported automatically in Blazor apps.

    Manually Trigger Scripts
    To do this, first we should add autostart="false" to related client side js file and then start it manually some where
    later in the body after our scripts using:
    Blazor.start()

    Another way to Start it manually is settings autostart=false and then adding an event handler for event:DoMContentLoaded
    as:
    document.addEventListener("DoMContentLoaded",function() {Blazor.start();});

    Since Start() return a promise we can use a then block to do the same thing we do in afterStarted hook.

    To define a JS initializer, add a JS module to the project named {NAME}.lib.module.js, where the {NAME} placeholder is
    the assembly name (Here BlazorWebAssemblySignalRApp.Client), library name (Razor Class libraries-RCL), or package
    identifier (For external Package). Place the file in the project's web root, which is typically the
    wwwroot folder.
    The module exports either or both of the following conventional functions:
    1- beforeStart(options,extensions): this runs before Blazor Start
    2- afterStarted(blazorInstance): this runs after Blazor Started

    Boot resources
    When a Blazor WebAssembly app loads in the browser, the app downloads boot resources from the server:
    * JavaScript code to bootstrap the app
    * .NET runtime and assemblies
    * Locale specific data

    there is a setting which is used in manual start of blazor webassembly which customize boot resources loading.
    this setting is loadBootResource:function(type,name,defaultUri,integrity) {}.
    for example we have:
    Blazor.start({
    loadBootResource: function (type, name, defaultUri, integrity) {
    console.log(`Loading: '${type}', '${name}', '${defaultUri}', '${integrity}'`);
    switch (type) {
    case 'dotnetjs':
    case 'dotnetwasm':
    case 'timezonedata':
    return `https://cdn.example.com/blazorwebassembly/5.0.0/${name}`;
    }
    }
    });

    Environment in Web Assembly Blazor
    Blazor Server is like a normal ASP.NET App and we can set the environment similarly. But in case of Blazor web assembly
    we use every server we want for backend (It does not need any thing in back just a server to host the files related to
    wasm). In case of Hosted wasm we have backend server as ASP.NET Core and in case of
    standalone we have a Dev Server which do similar role in development but in case of production we can use every web
    server. So on that case, to define the environment we can use a header named
    Blazor-Environment to set the environment. For example in case of hosted we have a middleware UseWebAssemblyDebugging
    which sets thise header to Development and in production it is default to Production.
    To specify the environment for other hosting environments, add the Blazor-Environment header. for example on case of IIS
    we can add it to web.config as header. To see web.config publish the project and see the publish folder in bin folder

    In case of standalone, if we use Dev Server package it sets the environment to development. to override this we can set
    the environment in StartUp of Blazor wasm (Which is in client side) using the following script:
    Blazor.start({
    environment:"Staging"
    });
    Using the environment property overrides the environment set by the Blazor-Environment header.

    Apps built and deployed with continuous integration (CI) in Azure?
    See the link:
    https://docs.microsoft.com/en-us/aspnet/core/blazor/fundamentals/environments?view=aspnetcore-6.0#set-the-environment-for-azure-app-service

    How to Get Environment in Startup or Components:
    * Obtain the app's environment in a component by injecting IWebAssemblyHostEnvironment
    * During startup, the WebAssemblyHostBuilder (app) exposes the IWebAssemblyHostEnvironment through the HostEnvironment
    property, which enables environment-specific logic in host builder code. Other usage is the
    IWebAssemblyHostEnvironment.BaseAddress property that can be used during startup when the NavigationManager service
    isn't available.

    What we can do with web assembly host builder?
    This is also uses generic host builder. The typical .NET Core App features like configuration, logging and dependency
    injection are configured on the level of
    the IHostBuilder.
    WebAssemblyHostBuilder has following properties:
    1- Services: Like other Host Builder it is the service container which is used for registering services
    2- Logging: This is used for Logging
    3- Configuration: used for configuration
    4- HostEnvironment: Shows Environment
    5- RootComponents: This is what make this host distinct from other host and is used for mapping between root components
    and root locations.

    Web Assembly Loging:
    This can do using the logging property of Host Builder as following:
    builder.Logging.SetMinimumLevel(LogLevel.Debug);
    builder.Logging.AddProvider(new CustomLoggingProvider());
    builder.Logging.AddConfiguration(builder.Configuration.GetSection("Logging"));
    - logging in Components: We can inject ILoggerProvider (Or ILoggerFactory in similar manner) or ILogger<T> (non generic
    ILogger throw error ) and use it like below in signalR connection builder:
    ConfigureLogging(logging => logging.AddProvider(_loggerProvider))

    This uses WebAssemblyConsoleLogger to log in browser using Mono inside browser. Unlike a traditional ConsoleLogger,
    WebAssemblyConsoleLogger is a wrapper around browser-specific logging APIs (for example, console.log).
    WebAssemblyConsoleLogger is internal and not available for direct use in developer code (Through browser?!).

    Persistent Log Provider
    Since web assembly runs on browser we need an API to persist the logs if we need. Here we need a Logging Provider which
    is also manages log size and log rotation. Alternatively, the app can use an Application Performance Management (APM)
    service, such as Azure Application Insights (Azure Monitor).


    PreRendering in Blazor Hosted Web Assembly
    A hosted Blazor WebAssembly app that prerenders its content executes component initialization code twice. Logging takes
    place server-side on the first execution of initialization code and client-side on the second execution of
    initialization code. (Pre Rendering Only happen if we explicitly add it. in this project it does not happen so every
    thing has happen once!)

    Error Handling for Unhandled Errors
    For an app to continue after an error, the app must have error handling logic. We also may need the exception details in
    case of development. In case of ASP.Net Core we have a middleware for this, but in case of Blazor web assembly this is
    different. In production, don't render framework exception messages or stack traces in the UI.
    For Blazor Server, logging is same as enabling SignalR Detail Error which can be using one of the following ways:
    1- Enabling it in Circuit Options (CircuitOptions.DetailedErrors in setting Hub/SignalR Services)
    2- Enable the above option through "DetailedErrors": true, in Configuration (for example appsettings.Development.json)
    3- Add SignalR server side logging through "Microsoft.AspNetCore.SignalR": "Debug"
    4- In way 2 we can set the configuration using environment variable ASPNETCORE_DETAILEDERRORS

    Blazor Server is a stateful framework. While users interact with an app, they maintain a connection to the server known
    as a circuit. The circuit holds active component instances, plus many other aspects of state, such as:
    1- The most recent rendered output of components.
    2- The current set of event-handling delegates that could be triggered by client-side events.

    Here, If a user opens the app in multiple browser tabs, the user creates multiple independent circuits.
    In Blazor server most of Unhandled exception considered fatal to Circuit. So user should reload the page to create a new
    circuite and continue. Of course other circuites in other Tabs do not closed!

    For Blazor WebAssembly we have not middleware pipeline, there is no middleware pipeline that processes requests for
    Razor components. The browser serves as the app's host and thus acts as the processing pipeline for individual Razor
    components based on URI requests for navigation and static assets. However, an app can use an error processing component
    as a cascading value to process errors in a centralized way (Error Boundries). The ErrorBoundary component:
    * Renders its child content when an error hasn't occurred.
    * Renders error UI when an unhandled exception is thrown.

    For example, an error boundary can be added around the body content of the app's main layout as following:
    <div class="main">
    <div class="content px-4">
    <ErrorBoundary>
    @Body
    </ErrorBoundary>
    </div>
    </div>
    By default, In case of Unhandled exception, the ErrorBoundary component renders an empty <div> element with the
    blazor-error-boundary CSS class for its error content. Yo can change this default behaviour using the following
    properties:
    <ErrorBoundary>
    <ChildContent>
    @Body
    </ChildContent>
    <ErrorContent>
    <p class="errorUI">Nothing to see here right now. Sorry!</p>
    </ErrorContent>
    </ErrorBoundary>
    One Problem with the above broad scope error boundary is that it shows the errors after happing in all the pages an you
    need to reload page. To prevent that, you can use narrow-scope error boundary or use the following approach in the
    relative component for example (Recover() method):
    ...

    <ErrorBoundary @ref="errorBoundary">
    @Body
    </ErrorBoundary>

    ...

    @code {
    private ErrorBoundary? errorBoundary;

    protected override void OnParametersSet()
    {
    errorBoundary?.Recover();
    }
    }
    *** In the above example see the usage of ref which bind a razor component/html element to a Property.

    Another approach for handling exception is using Cascading Component (This is something similar to React Context which
    is used to Share data (even component!) in all the hierarchy). Here we define a top cascading value error component
    having methods and properties for processing errors and then pass itself to use in every level of hierarchy for
    processing errors.
    An advantage of using a (Cascading) component over using an injected service or a custom logger implementation is that a
    cascaded component can render content and apply CSS styles when an error occurs. StateHasChanged base method of
    components may be required to apply changes in UI rendering.
    The value of Cascading Component can received using a Property with a CascadingParameter attribute.

    Places Where Error may happen:
    1- Component Instantiation: In this step the constructor of Component and all injected services are invoked.
    2- Component Life Cycle methods: (Review them later)
    3- Rendering: In this step the method of BuildRenderTree(RenderTreeBuilder builder) executes and builds up a data
    structure describing the elements, text, and child components of the rendered component.
    4- Event Handler: They are created to triggers invocations of C# code from Client-side code. Some of them are
    @bind,@onchange,@onclick and other events which starts with on.
    5- Component Disposal: A component may be removed from the UI, for example, because the user has navigated to another
    page. When a component that implements System.IDisposable (not all component implement that. you should add @implements
    IAsyncDisposable/IDisposable directive) is removed from the UI, the framework calls the component's Dispose
    method.
    6- JS interop: IJSRuntime.InvokeAsync allows .NET code to make asynchronous calls to the JavaScript runtime in the
    user's browser. But this method may throw exception in three case:
    * It fails synchronously: This is may happen if it could not serialize its parameters.
    * It fails asynchronously: This can be due to exception in JS or due to rejection of the promise that it should return.
    * It fails due to timeout: If the promise that it should return does not resolve in 1 minute it return an exception
    (OperationCanceledException).(This is not fatal)
    Similarly JavaScript code may initiate calls to .NET methods indicated by the [JSInvokable] attribute. If an exception
    happen in dotnet method it is not a fatal error and only reject the promise it returned.

    7- PreRendering: PreRendering happens only in case of using Component Tag Helper in razor pages (.cshtml). That can be
    the case in Blazor Server but only happen if backend is .Net for Blazor WebAssembly and we use index.cshtml instead of
    index.html. To handle exceptions here, instead of wrapping the ComponentTagHelper in a try-catch statement, place error
    handling logic in the component rendered by the ComponentTagHelper.
    https://docs.microsoft.com/en-us/aspnet/core/mvc/views/tag-helpers/built-in/component-tag-helper?view=aspnetcore-6.0

    SignalR and Blazor Server (Circuit)
    Blazor Server allows code to define a circuit handler, which allows running code on changes to the state of a user's
    circuit.
    A circuit handler is implemented by deriving from CircuitHandler and registering the class in the app's service
    container.
    If a custom circuit handler's methods throw an unhandled exception, the exception is fatal to the Blazor Server circuit.
    Use Try-Catch to handle these exceptions.
    When a circuit ends because a user has disconnected and the framework is cleaning up the circuit state, the framework
    disposes of the circuit's DI scope. Disposing the scope disposes any circuit-scoped DI services that implement
    System.IDisposable (I think it dispose every scoped services). If any DI service throws an unhandled exception during
    disposal, the framework logs the exception.

    Static Files in Blazor (wwwroot)
    By default, publishing a Blazor WebAssembly app places the app's static assets, including Blazor framework files
    (_framework folder assets), at the root path (/) in published output.
    The <StaticWebAssetBasePath> property specified in the project file (.csproj) sets the base path to a non-root path (In
    published app). This scenario is useful in case of hosting multiple Blazor Project using one host.
    <PropertyGroup>
    <StaticWebAssetBasePath>app1</StaticWebAssetBasePath>
    </PropertyGroup>
    The above Property changes:
    In published output:
    * Path to the client app in the Server project of a hosted Blazor WebAssembly solution:
    /BlazorHostedSample/Server/bin/Release/{TFM}/publish/wwwroot/app1/
    * Path to a standalone Blazor WebAssembly app: /BlazorStandaloneSample/bin/Release/{TFM}/publish/wwwroot/app1/


    Razor Component
    A component is a self-contained portion of user interface (UI) with processing logic to enable dynamic behavior.
    Components can be nested, reused, shared among projects, and used in MVC and Razor Pages apps.
    * A component's name must start with an uppercase character
    * Blazor follows the convention of ASP.NET Core apps for static assets. Static assets are located in the project's web
    root (wwwroot) folder or folders under the wwwroot folder. Components do not support tilde-slash notation (~/).
    * Routing in Blazor is achieved by providing a route template to each accessible component in the app with an @page
    directive. When a Razor file with an @page directive is compiled, the generated class is given a RouteAttribute
    specifying the route template. At runtime, the router searches for component classes with a RouteAttribute and renders
    whichever component has a route template that matches the requested URL.
    * Components that produce webpages usually reside in the Pages folder, but you can use any folder to hold components,
    including within nested folders. Components are ordinary C# classes and can be placed anywhere within a project.
    Components that produce webpages usually reside in the Pages folder. Non-page components are frequently placed in the
    Shared folder or a custom folder added to the project.
    * When an app is compiled, the HTML markup and C# rendering logic are converted into a component class. The name of the
    generated class matches the name of the file. Members of the component class are defined in one or more @code blocks
    * Components can include other components by declaring them using HTML syntax
    * Components doesn't have an @page directive isn't directly accessible to a user via a direct request in
    the browser. However, any component with an @page directive can be nested in another component.
    * WE can also create using code-behind files (.razor.cs) using Partial class. Actually generated component class are
    partial.
    * A component stylesheet that defines component-specific styles can be a separate file (.razor.css) ().
    * We can use a base class for components by inheriting (@inherits) from a class that inherits ComponentBase class (for
    example BlazorRocksBase : ComponentBase).
    * Unlike in Razor pages (.cshtml), Blazor can't perform asynchronous work in a Razor expression while rendering a
    component. Instead, asynchronous work is performed during one of the asynchronous lifecycle events, After each
    asynchronous lifecycle event, the component may render again. So the await Keyword
    is not support in razor markup (This has a logic behind). If we have a UI value that needs async work, it should be done
    in one of async lifecycle events and then set the result in a property and use that property instead.
    * Component attributes do not support complex content (mixed C# and markup). As a result concatinating of a text and a
    property does not support. We can do that in field/property/method and then use it instead.
    * Tag Helpers aren't supported in components. To provide Tag Helper-like functionality in Blazor, create a component
    with the same functionality as the Tag Helper and use the component instead.
    * Unless the @preservewhitespace directive is used with a value of true, extra whitespace is removed by default
    * We can add Razor components dynamicly using JavaScript using Blazor.rootComponents.add() function. It needs
    registering element for using from js in program/startup using builder.RootComponents.RegisterForJavaScript

    Component State
    In @code blocks, component state is specified and processed with C#:
    1- Property and field initializers.
    2- Parameter values from arguments passed by parent components and route parameters (Also CascadingParameter).
    3- Methods for user event handling, lifecycle events, and custom component logic.

    Component Parameters
    Component parameters pass data to components and are defined using public C# properties on the component class with the
    [Parameter] attribute. Type of Parameter can be built-in types and complex class types (User-defined Reference Types)
    and also Unnamed Tuples.
    The user defined types can be passed using explicit C# expression like new ... .
    Altough Providing initial values for component parameters is supported, but don't create a component that writes to its
    own parameters after the component is rendered for the first time.
    Parameter values are set by arguments in the HTML tag that renders the instance of the component (Or from route
    parameter and cascading values).
    Don't place custom logic in the get or set accessor because component parameters are purely intended for use as a
    channel for a parent component to flow information to a child component. If a set accessor of a child component property
    contains logic that causes rerendering of the parent component, an infinite rendering loop results.
    You can use parameters value in other properties to create/set transformed values (Work only once!). Override
    OnParametersSetAsync to transform a received parameter each time new data is received.
    If you want to make a Parameter mandatory at built time, you can Apply the [EditorRequired] attribute to specify a
    required component parameter (Of course it need [Parameter] attribute too). This does not have a runtime effect and does
    not gurantee a non-null value. We can use them as [Parameter, EditorRequired] too.
    Components can specify route parameters in the route template of the @page directive. The Blazor router uses route
    parameters to populate corresponding component parameters.
    We can also have catch-all route parameters ({*pageRoute}), which capture paths across multiple folder boundaries.
    We have an implicit type of Parameter which fed by Parents as child content. Its name is ChildContent and should be
    defined as property (RenderFragment?) in Child component too.
    Anoter way to define Parameter is using @attributes directive. Components can capture and render additional attributes
    in addition to the component's declared parameters. Additional attributes can be captured in a dictionary and then
    splatted onto an element when the component is rendered using the @attributes Razor directive attribute. Here we should
    define the Parameters in case of Child Razor components using the [Parameter] attribute to have access to them.
    otherwise we should use a CaptureUnmatchedValues parameter to catch others.
    In this case, The position of @attributes relative to the position of element attributes is important. for example if we
    have an element attribute that also defined in the component and has a key equal to element attribute, the last one
    overwrites here.

    Component Reference
    Component references provide a way to reference a component instance for issuing commands. To capture a component
    reference:
    1- Add an @ref attribute to the child component/html element.
    2- Define a field with the same type as the child component.
    When the component is rendered, the field is populated with the component instance. You can then invoke .NET methods on
    the instance.

    A component reference is only populated after the component is rendered and its output includes ReferenceChild's
    element. Until the component is rendered, there's nothing to reference.
    To manipulate component references after the component has finished rendering, use the OnAfterRender or
    OnAfterRenderAsync methods.

    To use a reference variable with an event handler (for example @onclick), use a lambda expression (evaluates in runtime)
    or assign the event handler delegate in the OnAfterRender or OnAfterRenderAsync methods. This ensures that the reference
    variable is assigned before the event handler is assigned.
    A good example of Refrence Component is using a component as a method and fields provider without any real html
    rendering. We add the component to get a refrence to it and then use the ref to reterieve fields and methods!
    Use a collection to reference components in a loop. You should manage adding reference to end of collection yourself by
    changing setter for @ref property. for example:
    private List<ReferenceChild> components = new();
    private ReferenceChild childComponent
    {
    set => components.Add(value);
    }

    To use this ref collection, you can invoke a delegate which get index of the exact ref component.
    Capturing component references isn't a JavaScript interop feature. Component references aren't passed to JavaScript
    code. Component references are only used in .NET code.
    Do not use component references to mutate the state of child components. Use of component parameters result in child
    components that rerender at the correct times automatically. The ref using may not garantee this.

    @key directive (similar to React key in list items)
    When we have a dynamic list of elements or components, Blazor must decide which of the previous elements or components
    can be retained and how model objects should map to them. Use of @key guarantees the preservation of elements or
    components based on the key's value. Keys are local to each container element or component. Keys aren't compared
    globally across the document. Altough main usage of Key is list items, You can also use @key to preserve an element or
    component subtree when an object doesn't change. The @key attribute directive is scoped to its own siblings within its
    parent.
    There's a performance cost when rendering with @key. The performance cost isn't large, but only specify @key if
    preserving the element or component benefits the app. Even if @key isn't used, Blazor preserves child element and
    component instances as much as possible. The only advantage to using @key is control over how model instances are mapped
    to the preserved component instances, instead of Blazor selecting the mapping.
    Generally, it makes sense to supply one of the following values for @key:
    1- Model object instances. This ensures preservation based on object reference equality.
    2- Unique identifiers. For example, unique identifiers can be based on primary key values of type int, string, or Guid.

    @attribute directive
    Add attributes like Authorize to Components using this directive.

    Raw HTML
    Strings are normally rendered using DOM text nodes, which means that any markup they may contain is ignored and treated
    as literal text. To render raw HTML, wrap the HTML content in a MarkupString value. The value is parsed as HTML or SVG
    and inserted into the DOM. We should use the MarkupString type (instead of string) to add a block of static HTML content
    to the rendered output of a component. Of course we can use RenderFragment but it should be defined using razor syntax!
    (needs @ and can get other c# expressions)


    Rendering tree
    The Blazor framework processes a component internally as a render tree, which is the combination of a component's
    Document Object Model (DOM) and Cascading Style Sheet Object Model (CSSOM). After the component is initially rendered,
    the component's render tree is regenerated in response to events. Blazor compares the new render tree against the
    previous render tree and applies any modifications to the browser's DOM for display.

    Render Fragment and Render Templates
    * Event callbacks aren't supported for RenderFragment. What about lifecycle Events?
    * RenderFragment is a Delegate which takes RenderTreeBuilder and write to it.
    * Render fragments can be defined using Razor template syntax to define a UI snippet (A complete alternative to
    MarkupString).
    * We have RenderFragment<T> which is a delegate receive an argument T and return a razor syntax template using that.

    Blazor Layout
    A Blazor layout is a Razor component that shares markup with components that reference it. Layouts can use data binding,
    dependency injection, and other features of components.
    To create a layout, we can create a component using cs class or razor component and inherit from LayoutComponentBase.
    Then use Body Property from LayoutComponentBase in the Layout. Body is a RenderFragment and Use the Razor syntax @Body
    to specify the location in the layout markup where the content is rendered.
    In an app created from a Blazor project template, the MainLayout component is the app's default layout. Blazor's CSS
    isolation feature applies isolated CSS styles to the MainLayout component. By convention, the styles are provided by the
    accompanying stylesheet of the same name, Shared/MainLayout.razor.css.
    To apply a layout we can do one of the followings:
    1- Use the @layout Razor directive to apply a layout to a routable Razor component that has an @page directive. The
    compiler converts @layout into a LayoutAttribute and applies the attribute to the component class. Specifying the layout
    directly in a component overrides a default layout which can be defined in following ways (in App.razor or Folder
    _imports.razor using @layout directive).
    2- Every folder of an app can optionally contain a template file named _Imports.razor. The compiler includes the
    directives specified in the imports file in all of the Razor templates in the same folder and recursively in all of its
    subfolders. Add @layout directive to apply a layout to them (only routable components). Do not add a Razor @layout
    directive to the root _Imports.razor file, which results in an infinite loop of layouts. Specifying a layout in
    _Imports.razor overrides a layout specified as the router's default app layout, which is described in the following.
    3- Specify the default app layout in the App component's Router component.We recommend using the Router component to set
    the app's default layout because it's the most general and flexible approach for using layouts.

    4- To apply a layout to an arbitary content we can use LayoutView Component which have a Layout property equal to typeof
    the Layout component. It can be used for nested layout too.
    5- A component can reference a layout that in turn references another layout. For example, nested
    layouts are used to create a multi-level menu structures

    HeaderOutlet Component
    This built-in component used for setting Page Headers like title and meta tags. The following components uses the
    HeaderOutlet:
    1- PageTitle: which adds Title to page.
    2- HeadContent: add contents to head element like meta elements

    When Razor components are prerendered, the use of a layout page (_Layout.cshtml) is required. It should Prerender the
    head content using the HeaderOutlet component as follows (BlazorServer vs blazorwebassembly):
    <component type="typeof(HeadOutlet)" render-mode="ServerPrerendered" />
    <component type="typeof(HeadOutlet)" render-mode="WebAssemblyPrerendered" />

    CascadingParameter and CascadingValue (Context in React)
    They provide a convenient way to flow data down a component hierarchy from an ancestor component to any number of
    descendent components and allow components to coordinate with each other across a component hierarchy. Unlike Component
    parameters, cascading values and parameters don't require an attribute assignment (It require Parameter Property!).
    Blazor framework provides CascadingValue component, which wraps a subtree of a component hierarchy and supplies a single
    value to all of the components within its subtree.
    To make use of cascading values, descendent components declare cascading parameters using the [CascadingParameter]
    attribute. Cascading values are bound to cascading parameters by type (Type is key for binding!).
    Similar to a regular component parameter, components accepting a cascading parameter are rerendered when the cascading
    value is changed. You can add IsFixed=true parameter to it to indicate it should not change after initialization.
    To have multiple cascading values of same type you should use Name property for CascadingValue component to
    differentiate them (<CascadingValue Value="@parentCascadeParameter1" Name="CascadeParam1">) and to use one of them in
    child component you should use Name in CascadingParameter Attribute as [CascadingParameter(Name = "CascadeParam1")].
    We can also elevate state using CascadingValue between component hierarchy. for this purpose one approach is to set this
    as instance of component as Value. Then you can call it and have access to its StateHasChanged method to rerender
    children. Another approach is to pass the StateHasChanged method as a property in the Value Type.

    Data binding (Input Controls)
    Razor components provide data binding features with the @bind Razor directive attribute with a field, property, or Razor
    expression value.
    By default, When an <input> element loses focus, its bound field or property is updated. The text box is updated in the
    UI only when the component is rendered, not in response to changing the field's or property's value. But Since
    components render themselves after event handler code executes, field and property updates are usually reflected in the
    UI immediately after an event handler is triggered. It is like Controlled Inputs in React but onchange event triggered
    OnBlur!! (See BindingTheory.razor). In general, @bind associates the current value of an expression with a value
    attribute and handles changes using the registered handler. Bind a property or field on other Document Object Model
    (DOM) events by including an @bind:event="{EVENT}" attribute with a DOM event for the {EVENT} placeholder.
    for example we have onchange and oninput events. Unlike the onchange event, which fires when the element loses focus,
    oninput fires when the value of the text box changes.
    In binding process, When a user provides an unparsable value to a databound element, the unparsable value is
    automatically reverted to its previous value when the bind event is triggered.
    There is custom Form validation components provide built-in support to manage invalid inputs. We can study them in
    related section.
    Also we can define format for date fields in case where we use input type as text. If you use input type as date then
    you possibly always get error. This feature only availabe for date and not for currency or numbers! What about Regular
    Expressions?! for them C# get and set accessors can be used to create custom binding format behavior.

    Child Binding (Chain Binding)
    There is situation that you want to set a parameter of child component such that child component can change the
    parameter property in a safe way directly from Parent component. There is a way that use the CascadingValue. but a
    better way is to bind the parameter in child to an expression (or Property or field) in parent and as a result you have
    access to a delegate which can invoke to change the expression in Parent and then rerender it to change the Parameter of
    child.
    if we have a {Property} in Parent which we want bind to a property in child we should use two Component parameters in
    child which permit binding properties of a parent component with @bind-{PROPERTY} syntax, where the {PROPERTY}
    placeholder is the parent property to bind. By convention, the EventCallback<TValue> for the parameter must be named as
    the component parameter name with a "Changed" suffix. The naming syntax is {PARAMETER NAME}Changed, where the {PARAMETER
    NAME} placeholder is the parameter name. It also need the type matches. If you want to specify other name, By
    convention, you should specify it in Parent by including an @bind-{PROPERTY}:event attribute assigned to the handler,
    where the {PROPERTY} placeholder is the property. The following are equaled by convention:
    <Child @bind-Year="year" @bind-Year:event="YearChanged" />
    <Child @bind-Year="year"/>

    Using the child Binding there is another binding for inputs which used as below:
    <input @bind-value="myProp" />
    This binds value property of input to myProp property and there is a ValueChanged Callback which trigged after OnBlur native (Blazor) event for input box.

    Nested Binding (this is chaind binding)
    We can have binding between multiple levels of component hierarchy. You can bind parameters through any number of nested
    components, but you must respect the one-way flow of data:
    1- Change notifications flow up the hierarchy.
    2- New parameter values flow down the hierarchy.
    As you can see in the example, the middle components chaind to do 1 and 2 between parent and lowest level component
    using a property which has a setter that uses the immidate parent call back and do not short circuit the follow.

    Event Handling in Blazor (Razor Component)
    Event handling in Blazor component to DOM Events do through defining a delegate and specify it as:
    @on{Event}="DelegateName"
    For event handling:
    * Asynchronous delegate event handlers that return a Task are supported.
    * Delegate event handlers automatically trigger a UI render, so there's no need to manually call StateHasChanged.
    * Exceptions are logged.

    For events that support an event argument type, specifying an event parameter in the event method definition is only
    necessary if the event type is used in the method. There is lots of events but there is small EventArgs Types. for
    mapping between them see the following link:
    https://docs.microsoft.com/en-us/aspnet/core/blazor/components/event-handling?view=aspnetcore-6.0
    We also can use lambda expression delegate as event handler delegate. This is specially useful when we want to pass more
    than event arguments to the event handler.

    Create Custom Event in Blazor
    We can catch event currently exist in the dom with our custom argument and then handle them in blazor. If bubbling is
    enabled for event we can handle event in parent component too (It is nature of event and readonly). Blazor supports
    custom event arguments, which enable you to pass arbitrary data to .NET event handlers with custom events.
    To define and use a custom event we should do something in JavaScript and in .Net as below:
    1- In JavaScript, define a function for building the custom event argument object from the source event (It can define
    in step 2 as lambda expression too).
    2- Register Custom Event: Here we define mapping between custom event and its arguments to an existing DOM Event in JS.
    To Register an event, we should use:
    Blazor.registerCustomEventType("customevent",{browserEventName:"nativeevent",createEventArgs:e => ({here we return the
    arguments from e (This function can be defined in step 1 too!)})});
    3- Define a class for custom event arguments in .NET inheriting from EventArgs. The name of arguments here is PascalCase
    equal to camelCase in step 1,2.
    4- Wireup between .Net class for event argument and the event using an empty class named EventHandlers which have an
    EventHandlerAttribute
    (this attribute has 4 arguments including event name as oneventname, event arg type as class defined in step 3,
    EnablePropagateEvent, EnablePreventDefault)
    5- use event like built-in events (always use event name in .NET with an on as oncustomevent vs customevent in JS).
    Here we can use built in event as source or define custom event in js and use them. The event should dispatch in a
    script and should have bubbles:true to catch by Blazor components.


    Event callback
    A common scenario with nested components is executing a parent component's method when a child component event occurs.
    We already have an special case of it when using two-way parameter binding in childs. but here we want to extend it in a
    way that we can execute an arbitary method of parent as an event handler in child components.
    Event Callback is a not a delegate altough it seems but it works like a delegate which it seems implemented by Blazor in
    a way that call its constructor(event,delegate) and it has an InvokeAsync method which called when it triggered.
    StateHasChanged is called automatically to rerender the Parent component, just as child events trigger component
    rerendering in event handlers that execute within the child.
    EventCallback and EventCallback<TValue> permit asynchronous delegates. EventCallback is weakly typed and allows passing
    any type argument in InvokeAsync(Object). EventCallback<TValue> is strongly typed and requires passing a T argument in
    InvokeAsync(T) that's assignable to TValue. Use EventCallback when there's no value passed to the callback.
    You can also Invoke an EventCallback or EventCallback<TValue> with InvokeAsync and await the Task directly in child.
    This also make parent component rerender.
    Use the @on{DOM EVENT}:preventDefault directive attribute to prevent the default action for an event. for example when
    the focus is on an input, when pressing a button (onkeydown) after executing the assigned handler (if any exists!),
    browser by default show the pressed key on input. we can prevent this by enableing preventDefault as
    onkeydown:preventdefault on the input onkeydown event.
    Use the @on{DOM EVENT}:stopPropagation directive attribute to stop event propagation within the Blazor scope.
    The stopPropagation directive attribute's effect is limited to the Blazor scope and doesn't extend to the HTML DOM.
    Events must propagate to the HTML DOM root before Blazor can act upon them. For a mechanism to prevent HTML DOM event
    propagation, consider the following approach:
    * Obtain the event's path by calling Event.composedPath() (This method returns An array of EventTarget objects
    representing the objects on which an event listener will be invoked).
    * Filter events based on the composed event targets (EventTarget): Element, and its children, as well as Document and
    Window, are the most common event targets, but other objects can be event targets, too. For example XMLHttpRequest,
    AudioNode, and AudioContext are also event targets.Many event targets (including elements, documents, and windows) also
    support setting event handlers via onevent properties and attributes but you can also use addEventListener,
    removeEventListener and dispatchEvent methods on them.
    Call FocusAsync on an element reference to focus an element in code (@ref).

    Blazor Razor Components lifecycle
    The Razor component processes Razor component lifecycle events in a set of synchronous and asynchronous lifecycle
    methods. The lifecycle methods can be overridden to perform additional operations in components during component
    initialization and rendering. Rendering Cycle as a part of component lifecycle may happen after one of the following:
    1- Child Component Rendering By Parent Component
    2- Event Processing Fired by DOM: In this case, Rendering cycle happens at the end of completing all async Tasks.

    Child Component Rendering By Parent Component:
    * First time: 1- Create Component Instance and running SetParametersAsync (This can be overridden too) 2-
    OnInitializedAsync Hook (may have an
    additional rendering cycle here) 3- OnParametersSetAsync Hook 4- Rendering cycle
    * Re-rendering: 1-OnParametersSetAsync 2- Rendering cycle

    Here, we may have an additional component rendering cycle in case of Uncompleted Async Task after completing the
    OnInitializedAsync hook. So it may be possible
    that we have one rendering cycles after each hook completion.

    Rendering lifecycle
    After initial rendering or if ShouldRender method returns true this lifecycle continues otherwise it ends. in this case
    the following step happens:
    1- Build Render Tree difference and send render batch to DOM
    2- Call OnAfterRenderAsync Hook: By Default, this does not trigger Rendering lifecycle again.

    To trigger Rendering Lifecycle manually, we can call StateHasChanged().

    SetParametersAsync
    This method calls in initialization of component and can be overridden. Parameter can come from different source
    including route parameters, Parent component or CascadingValue components. This method has an argument named
    ParameterView which has parameter values from sources.
    The default implementation of SetParametersAsync sets the value of each property with the [Parameter] or
    [CascadingParameter] attribute that has a corresponding value in the ParameterView. Parameters that don't have a
    corresponding value in ParameterView are left unchanged.
    In case of overriding it, If base.SetParametersAsync isn't invoked, developer code can interpret the incoming
    parameters' values in any way required. We can use ParameterView.TryGetValue (key) to get the parameter value but it is
    case sensitive!!! (This is different than insensitive case in Route Parameter matching which only applicable to route
    template)

    OnInitializedAsync (Component Initialization Hook)
    OnInitialized and OnInitializedAsync are invoked when the component is initialized after having received its initial
    parameters in SetParametersAsync (Calling base.SetParametersAsync is required in case of customization of
    initialization). There is a synchronized version of this too (OnInitialized).
    OnInitializedAsync called twice in case of PreRendering:
    1- When component rendered staticly as a part of the Page (.cshtml)
    2- When the browser render the component as second time
    So we should do some measures to prevent running the code twice in case of destructive behaviour for example adding a
    counter or calling a costly API (This can be prevent in Blazor Server using Cache). Also consider that in case of
    PreRendering calling into JavaScript (JS interop), aren't possible.

    OnParametersSetAsync (On Parameters Set Hook)
    This is useful for dynamic UI since it calls in case of rerendering too. It calls in two situations:
    1- it called at the end of OnInitialized (or synchronized OnInitializedAsync)
    2- It called in case of rerendering by parent if one of the followings happen:
    * at least one primitive type parameter changed.
    * at least one of the parameter is complex type (It can not detect change so the framework always treats the parameter
    set as changed when one or more complex-typed parameters are present.)

    OnAfterRenderAsync Hook (After Rendering the component at the end of Rendering Cycle)
    This Hook happens after updating DOM at the end of rendering cycle. OnAfterRender and OnAfterRenderAsync are called
    after a component has finished rendering. Element and component references are populated at this point. Use this stage
    to perform additional initialization steps with the rendered content, such as JS interop calls that interact with the
    rendered DOM elements. Does StateHasChanged called by this automatically? No. It make an infinite loop!
    It has an argument which it specify it is first render or not set by framework! This is usually used for exception
    handling in case of Asynchronous task in OnInitializedAsync and OnParametersSetAsync or JS Interop calls.
    There are some point which we should consider about OnAfterRender Or OnAfterRenderAsync:
    1- Rendering cycle does not call after it so the change are not show in the page. Dont call the StateHasChanged since it
    cause infinite loop.
    2- OnAfterRender and OnAfterRenderAsync aren't called during the prerendering process on the server. The methods are
    called when the component is rendered interactively after prerendering.
    3- To delay JavaScript interop calls until a point where such calls are guaranteed to work, override the
    OnAfterRender{Async} lifecycle event. This event is only called after the app is fully rendered.

    StateHasChanged (Trigger rerendering by developer)
    StateHasChanged notifies the component that its state has changed. When applicable, calling StateHasChanged causes the
    component to be rerendered. StateHasChanged is called automatically for EventCallback methods.

    Dispose() (Component Disposal)
    If a component implements IDisposable, IAsyncDisposable, or both, the framework calls for unmanaged resource disposal
    when the component is removed from the UI.
    In this method we should dispose object with unmanaged resources which implemented IDisposable and also Unsubscribe
    event handlers from .NET events that subscribed on lifecycle methods. Event Handler can defined as private method or a
    private field with typ EventHandler<ArgType> and lambda expression and subscribed to events at lifecycle methods.
    If the object is created in a lifecycle method, such as OnInitialized/OnInitializedAsync, check for null before calling
    Dispose. In case of lambda expression and anynomouse function event handlers it is not required to Unsubscribe theme on
    dispose. but only use the those approaches when you know that the event delegate disposes quickly and do not outlive the
    component. Calling StateHasChanged in Dispose isn't supported. We can use also Dispose method to cancel background task
    on navigating page to other pages.

    Re-Rendering Component (After the first rendering)
    The following trigger event rerendering:
    1- Updating Parameters in Parent or Component Value (In this case it does'nt always rerender)
    2- After invoking an event handler of component itself (If event handler is a Task it rerenders at two points: 1- at
    first return of handler (synchronously re-render) and at the Task Completion (asynchronously re-render))
    3- After calling StateHasChanged method of component.

    Case 1 does not rerender if either:
    * Component ShouldRender() method return false Or
    * Component have only primitive type parameters and they are not changed after update!

    Case 2: In case of Asynchronous event handlers we have two re-render (Asynchronous render and synchronous render)
    Case 3: Some common case of calling StateHasChanged:
    * When we want to have a rerendering in multiple points in a async event (more than 2 default rerender).
    * External Events (All events which not trigged by Blazor like a Timer Or Notifications service): In this cas
    StateHasChanged can only be called from the renderer's synchronization context and throws an exception otherwise
    (Marshalling to UI thread). Use ComponentBase.InvokeAsync to move a work item onto the renderer's synchronization
    context. the execution call stack typically remains on the renderer's synchronization context, calling InvokeAsync isn't
    normally required. Calling InvokeAsync is only required if the logic escapes the synchronization context, such as
    calling ContinueWith on a Task or awaiting a Task with ConfigureAwait(false).
    * When using an state manager: consider we want To render a component outside the subtree that's rerendered by a
    particular event. In this case we create a State Manager class and add it to DI container. When one component calls a
    method on the state manager, the state manager raises a C# event that's then received by an independent component.

    The overall effect of the framework's conventions is that the component receiving an event rerenders itself, which
    recursively triggers rerendering of descendant components whose parameter values may have changed. we have two special
    case:
    1- we want to prevent rerendering due to above triggers: override ShouldRender() method to return false in desired
    cases.
    2- Calling StateHasChanged allows you to trigger a render at any time.

    Consider that in case of @bind it update dom even in case of ShouldRender return false altough it does not rerender the
    Blazor component. In case of child binding to a parameter since it needs rerender (due to its nature of event callback)
    to update the dom, DOM does not
    change.



    Cancelling Background Work
    There is situation that background work needs to cancel manually, for example background asynchronous operations don't
    automatically stop when a user navigates away from a component. As an example of Background Task we can see long-running
    background work, such as making network calls (HttpClient) and interacting with databases. Other examples includes:
    * Starting a task with wrong parameters and data.
    * There is task with more priority.
    * In case of Server, we want to shut down it or due to load we want to reschedule the tasks.
    To implement Cancellable Task we should do followings:
    1- Have a CancellationTokenSource (cts) and so a CancellationToken (cts.Token)
    2- Use ThrowIfCancellationRequested on async background task and CancellationToken
    3- To signal the async background task to cancel call cts.Cancel method (for example in component
    disposal and do not forget to dispose the cts too)

    Templated Components
    Templated components are components that accept one or more UI templates (RenderFragment or RenderFragment<T>) as
    parameters, which can then be used as part of the component's rendering logic. Templated components allow you to author
    higher-level components that are more reusable than regular components (Consider Table or List Component for example).
    RenderFragment Represents a segment of UI content, implemented as a delegate that writes the content to a
    RenderTreeBuilder (public delegate void RenderFragment(RenderTreeBuilder builder);).
    RenderFragment<T> Represents a segment of UI content for an object of type TValue, implemented as a function that
    returns a RenderFragment (A Razor template of that object).
    To set a RenderFragment or RenderFragment<T> Paramter in a Component you can set them as a child component with name of
    Parameter (The
    ChildContent Parameter which can be specified directly as child in normal component should be defined similarly here!).
    To specify RenderFragment<T> input you can specify it
    as context parameter in the Rekated Component or in Templated Component itself or use @context directly. Could we
    specify them directly as Razor Template or Delegates which Return Razor templates? Yes it is possible!
    Often, templated components are generically typed, and we specify its Generic Type using @typeparam directive. in Using
    Templated Component we should set it as a parameter with similar name (Sometimes it infered from other paramter).
    Also there is situation that you may want that type specified in an ancestor Templated Component pass to Type uses in
    child Templated Component. One way is to define a parameter in ancestor as Type and use it in children in development
    time. Other approach which is more restericted is to use CascadingTypeParameter attribute in ancestor and then use the
    name specified automatically in templated component with same Type Parameter name (Here Childs used as child content
    specially and are parts of main components. for example consider a chart component with multiple similar parts like
    lines, axes, bars!).
    In case of Generic Templated Components we can also resteric defined type using where as @typeparam TEntity where
    TEntity : IEntity.

    CSS isolation
    Isolate CSS styles to individual pages, views, and components to reduce or avoid:
    * Dependencies on global styles that can be challenging to maintain.
    * Style conflicts in nested content.

    There is similar thing in Nod.js named CSS module.
    To define component-specific styles, create a .razor.css file matching the name of the .razor file (not case sensitive)
    for the component in the same folder. The .razor.css file is a scoped CSS file.
    CSS isolation occurs at build time. Blazor rewrites CSS selectors to match markup rendered by the component (adding a
    unique property for each component an assigne it to both css and html). The rewritten CSS styles are bundled and
    produced as a static asset. The stylesheet is referenced inside the <head> tag of wwwroot/index.html (Blazor
    WebAssembly) or Pages/_Layout.cshtml (Blazor Server). The following <link> element is added
    by default to an app created from the Blazor project templates, where the placeholder {ASSEMBLY NAME} is the project's
    assembly name (Should be added by developer if does not exist in template):
    <link href="{ASSEMBLY NAME}.styles.css" rel="stylesheet">
    <link href="BlazorWebAssemblySignalRApp.Client.styles.css" rel="stylesheet" />

    As said above, Within the bundled file, each component is associated with a scope identifier. For each styled component,
    an HTML attribute is appended with the format b-{STRING}, where the {STRING} placeholder is a ten-character string
    generated by the framework.
    By default, CSS isolation only applies to the component you associate with the format {COMPONENT NAME}.razor.css, where
    the placeholder {COMPONENT NAME} is usually the component name. To apply changes to a child component, use the ::deep
    combinator to any descendant elements in the parent component's .razor.css file. The ::deep combinator selects elements
    that are descendants of an element's generated scope identifier.
    In the above syntax, for example (::deep .card-body) the css apply to all .card-body elements which is descendent to
    current element! It apply as [b-3lle12or23] .card-body. Also consider that specified styled in child overwrites this
    styles.

    Collocation of JS Files (Only for organization and do not do nothing by itself)
    Collocation of JavaScript (JS) files for pages, views, and Razor components is a convenient way to organize js scripts
    in
    an app. Collocate JS files using the following filename extension conventions:
    * Pages of Razor Pages apps and views of MVC apps: .cshtml.js
    * Razor components of Blazor apps: .razor.js
    This Collocated JS files are publicly addressable/accessible through browser using the path to the file in the project
    (for example it starts with "/Pages" in case of Razor Pages and "/Views" for MVC App and "/RCLName" in case of Razor
    class Library).
    As already it said, these files are to organize JS and page/view/component and do not do any thing by itself. When the
    app is published, the framework automatically moves the script to the web root (But address remain as before and No
    change is required to the script's relative URL!(Actually it create folder structure inside wwwroot in a way that its
    URL works correctly)).
    To call a js file in a component we can import it on OnAfterRenderAsync as a module using js import function as below:
    module = await JS.InvokeAsync<IJSObjectReference>(
    "import", "./Pages/Index.razor.js");
    Here JS injected using @inject IJSRuntime JS and the script file should be as js module with exports to be used after
    import (Have export). for example:
    export function showPrompt(message) {
    return prompt(message, 'Type anything here');
    }


    DynamicComponent Component
    This built-in component used to render other component specifying their types. it has two properties including Type
    which specify type of component to render and Parameters which specify parameters of the specified component as a
    dictionary.
    A DynamicComponent is useful for rendering components without iterating through possible types or using conditional
    logic.
    How this approach is different than using the component directly? It seems that there is no difference when all
    parameters are objects but in case of event call back parameters it can not work since delegate does not inherited from
    object. The Type and Parameters property are in following types:
    <DynamicComponent Type="@componentType" Parameters="@parameters" />
    @code {
    private Type componentType = ...;
    private IDictionary<string, object> parameters = ...;
    }
    It also has a readonly property named Instance which save the Component instance create of type Object. To get we can
    use @ref to get the dynamic component instance and then to get its Instance property simply get.

    PreRendering
    Razor components can be integrated into Razor Pages and MVC apps. When the page or view is rendered, components can be
    prerendered at the same time. While an app is prerendering, certain actions, such as calling into JavaScript, aren't
    possible. Components may need to render differently when prerendered.
    In case of Prerendering, Components can be render in 2 ways (Child component does not considered here since they render
    in their parents):
    1- Directly as Routable components (Have @page directive)
    2- Components that used in Razor Page or MVC Views using Component tag helper (They can have or have not @page
    directive)

    Configuration for PreRendering (Blazor Server):
    1- add HeadOutlet component to Layout.cshtml (since PageTitle and HeadContent component need it to works). This also
    need to specify the base url that app is going to work (in case of WebAssembly render-mode changes):
    <base href="~/" /> (the framework recognise a tilde ('~') as a shortcut to the root of the application's virtual
    directory)
    <component type="typeof(HeadOutlet)" render-mode="ServerPrerendered" /> (This is not required in Blazor wasm index.html
    altough it is required for prerendering!)
    2- Add a <script> tag for the blazor.server.js Or blazor.webassembly.js script immediately before the Scripts render
    section. The framework adds the blazor.server.js script to the app. There's no need to manually add a blazor.server.js
    script file to the app (_Layout.cshtml).
    3- Use components using Component Tag Helper in Index.cshtml:
    <component type="typeof(Counter)" render-mode="ServerPrerendered" />

    To support routable Razor components in Razor Pages apps we should add App.razor component to the project root (It is
    necessary to add it in root since Blazor adds the route templates to route table!) and then
    add it to _Host.cshtml using Component tag helper (This is need for prerendering and bootstraping Blazor in browser
    side!).In this scenario, components use the shared _Layout.cshtml file for
    their layout (Of course we have an special Blazor Layout too which works for Razor components and it has not head
    section since it only works inside the element specified in _Host.cshtml!). render-mode can be
    ServerPrerendered,Server or Static which only the first is prerendered. Parameters can be set using param-* fields in
    Component tag helper.

    interactive vs stateful interactive vs none-interactive
    In case of using component tag helper in razor Page or view, the component can have one of the following state:
    1- none-interactive: In tag helper we use render-mode=Static and we set initial parameters of component specified in
    component tag helper. For example:
    <form>
    <input type="number" asp-for="InitialValue" />
    <button type="submit">Set initial value</button>
    </form>

    <component type="typeof(Counter)" render-mode="Static"
    param-InitialValue="InitialValue" />

    @functions {
    [BindProperty(SupportsGet=true)]
    public int InitialValue { get; set; }
    }

    2- interactive-stateful: We specify initial value for parameter in server (This is only used for SEO since it lost by
    initing the component. To compare use a precise date time parameter) and also open a signalR connection to do live
    interaction on component. We need to set render-mode=ServerPrerendered. In this case a blink happen since Blazor in
    browser start to init component without parameters but signalR send the values to it afterward!
    3- interactive-stateless: We do not specify initial value for component in the server. It sets in browser for example
    using web apis.

    Where we should place Blazor Razor components?
    We can add them every where in project but they should have .razor extension.

    Persist prerendered state

    Without persisting prerendered state, state used during prerendering is lost and must be recreated when the app is fully
    loaded (in Browser side). If any state is setup asynchronously (For example calling web apis on component init), the UI
    may flicker as the prerendered UI is replaced with temporary placeholders and then fully rendered again.
    To solve these problems, Blazor supports persisting state in a prerendered page using the Persist Component State Tag
    Helper. To use this tag helper: 1- Add the Tag Helper's tag, <persist-component-state />, inside the closing </body>
    tag and 2- Do some on component itself.
    Using this component adds a service PersistentComponentState which give use three method:
    1- PersistAsJson<TValue>(String, TValue):Serialize what we want to persist and persist it on its given key.
    2- RegisterOnPersisting(Func<Task>): we can register a callback to save some data that we want as state.
    3- TryTakeFromJson<TValue>(String, TValue): Using this we can take a persisted json data and get it deserialized. After
    getting the item, it is removed.
    Actually the service pause after prerendering and do the callback and we can use the method 1,2 in callback and our
    component to take the state back in client side in component init (See WeatherForecastPreserveState component).
    By initializing components with the same state used during prerendering, any expensive initialization steps are only
    executed once. The rendered UI also matches the prerendered UI, so no flicker occurs in the browser.

    for Blazor WebAssembly the following config should be done:
    1- Use the hosted model of WebAssembly
    2- Delete index.html and related builder.RootComponents.Add lines in Program.cs in client
    3-Add _Host.cshtml and _Layout.cshtml files to the Server project's Pages folder. The use of a layout page
    (_Layout.cshtml) with a Component Tag Helper for a HeadOutlet component is required:
    <Base href="~/" />
    <component type="typeof(HeadOutlet)" render-mode="WebAssemblyPrerendered" />
    4- add css address from wwwroot in client and the auto created css as below in Layout:
    <link href="css/app.css" rel="stylesheet" />
    <link href="BlazorWebAssemblySignalRApp.client.styles.css" rel="stylesheet" />
    5- add JavaScript at the end of body in Layout:
    <script src="_framework/blazor.webassembly.js"></script>
    6- Add Component tag helper for app to _Host.cshtml as below (Prerendering isn't supported for authentication endpoints
    (/authentication/ path segment)):
    <component type="typeof(App)" render-mode="WebAssemblyPrerendered" />
    7- In Server routing, change the fallback from the index.html file to the _Host.cshtml page
    app.MapFallbackToPage("/_Host");
    8-Register services required in Server too. For example HttpClient

    note: Avoid placing the same file (for example, favicon.ico) into both the Client and Server wwwroot folders. If the
    same file is present in both folders an exception is thrown because the static asset in each folder shares the same web
    root path.
    note: If you want to add a component to a MVC or Razor Page project and there is only one page which needs Blazor
    framework, you can add style and js file to that page/view and not necessary to add it to Layout altough you should add
    HeadOutlet component to related Layout if exist any. Typically, scripts are added to a page or view's Scripts render
    section and stylesheets are added to the layout's <head> element content.
    note: As an alternative to Component Tag Helper we can use RootComponents and css selectors to add a Blazor component to
    a razor page or view.

    Razor class Library
    Components can be shared in a Razor class library (RCL) across projects. An RCL can include static assets too.
    In addition to this RCL can be used for separating an app functionality and rendering into another assembly for example
    using area. To create an RCL we should use the following command:
    dotnet new razorclasslib (-s)
    -s specify Whether to support adding traditional Razor pages and Views in addition to components to this library.
    In this case (-s) you may add an _Imports.razor file to root of the generated RCL project:
    @using Microsoft.AspNetCore.Components.Web
    and Add the following SupportedPlatform item to the project file (.csproj):
    <ItemGroup>
    <SupportedPlatform Include="browser" />
    </ItemGroup>
    But if use the dotnet new razorclasslib without any option (-s) it has _import.razor and SupportedPlatform by default.

    To consume components from an RCL in another project, After adding reference to the component library (RCL), use either
    of the following approaches:
    1- Use the full component type name, which includes the RCL's namespace (For example <ComponentLibrary.Component1>).
    2- Individual components can be added by name without the RCL's namespace if Razor's @using directive declares the RCL's
    namespace. @using can be added in component level or _Imports.razor.

    You can use Css isolation stylesheet (.razor.css) without any further attempts in Components in RCL. But to use static
    stylesheets there you should use link inside HeadContent Component as described below. For Collocated JavaScript files
    you can import them from _content folder (Since it runs in client side ). Actually every thing that done in built time
    (like isolated style sheet which bundled and import in built time) can be used without any further attempts but things
    that do in runtime like static assets in wwwroot (Additional stylesheets and image and fonts and Collocated) should be
    get from _content folder. In case of Collocated js scripts it moved to wwwroot folder of RCL in first step (builting RCL
    itself) and then all static items of RCL move to a folder with name of RCL package id inside _content folder inside
    wwwroot of App. other things do in runtime.

    For library components that use CSS isolation, the component styles are automatically made available to the consuming
    app. There's no need to manually link or import the library's individual component stylesheets or its bundled CSS file
    in the app that consumes the library. The app uses CSS imports to reference the RCL's bundled styles. The bundled styles
    aren't published as a static web asset of the app that consumes the library and the RCL's stylesheet is imported at the
    top of the app's stylesheet automatically at build time. It create One bundle for total library and import it in
    generated style sheet for app assembly.
    The static assets like The background image is also included from the RCL project template and resides in the wwwroot
    folder of the RCL. The url to include them is something as follow:
    http://localhost:5104/_content/ComponentLibrary/background.png
    Actually reference the static assets with the following path in the app: _content/{PACKAGE ID}/{PATH AND FILE NAME}. The
    {PACKAGE ID} placeholder is the library's package ID. The package ID defaults to the project's assembly name if
    <PackageId> isn't specified in the project file. The {PATH AND FILE NAME} placeholder is path and file name under
    wwwroot.
    To include in the RCL's wwwroot folder the static asset directly in other part of the app, refrence the asset as below.
    <img alt="Image from Component Library" src="_content/ComponentLibrary/background.png" />

    In case of static stylesheet, To provide additional library component styles from stylesheets in the library's wwwroot
    folder, link the stylesheets using the framework's HeadContent component in component itself inside RCL (Of course as an
    alternative you can use html link directly in head of App too).
    <HeadContent>
    <link href="_content/ComponentLibrary/additionalStyles.css" rel="stylesheet" />
    </HeadContent>

    In case of Collocated JS we should import them using address as below:
    var module = await JS.InvokeAsync<IJSObjectReference>("import", "./_content/ComponentLibrary/Index.razor.js");


    In RCL you may have services too. But since they are not started or registered any where to use them or to use some
    components, you should register them in services first. (See ExampleJsInterop and Component1.razor in ComponentLibrary
    RCL)
To be continue at Index.razor


    // View Component From Andrew Connel (Only Documentation and not related to Blazor)
    In Razor Page or View we can add partials which handle custom rendering logic. But what if we have some custom business
    logic here too? The response is to use view component here. View components operate independently of the main Razor Page
    and can be used to encapsulate complex business logic. for example in case of Stack overflow web site, we have other
    sections where Each section contains business logic (deciding which posts or ads to show), database access (loading the
    details of the posts), and rendering logic for how to display the data. We can use layouts and partial views to split up
    the rendering of a view template into similar sections, but partial views aren’t a good fit for this example. Partial
    views let you encapsulate view rendering logic, but not business logic that’s independent of the main page content.
    Instead, view components provide this functionality, encapsulating both the business logic and rendering logic for
    displaying a small section of the page. You can use DI to provide access to a database context, and you can test them
    independently of the view they generate, much like MVC and API controllers. Think of them a bit like mini-MVC
    controllers, or mini-Razor Pages, but you invoke them directly from a Razor view, instead of in response to an HTTP
    request. So you can’t use filters with view components.
    To use them, you have two Options:
    1-Invoke view components directly from Razor views and layouts using a Tag Helper-style syntax, using a vc: prefix:
    <vc:my-recipes number-of-recipes="3"></vc:my-recipes>
    To use a view component as a Tag Helper, register the assembly containing the view component using the @addTagHelper
    directive.
    2- There is a property in Razor View/Pages named Component which implements IViewComponentHelper. We can use its
    InvokeAsync method for example as below:
    @await Component.InvokeAsync("MyRecipes", new { numberOfRecipes = 3 })
    3- Return it as result of an action in controllers
    return ViewComponent("MyRecipes", new { numberOfRecipes = 3 });

    To create them we should inherit from ViewComponent (Something similar to ControllerBase which have some helper methods
    and properties) and implement its InvokeAsync method. The other difference with Controller here is that the parameters
    of this method could not bind to request and should be passed when calling it. Similar to them the class name should end
    to ViewComponent or we should use [ViewComponent] attribute for class.
    view components must render some sort of content, so you can’t return status codes or redirects. You’ll typically use
    the View() helper method to render a partial view template (as in the previous listing) though you can also return a
    string directly using the Content() helper method, which will HTML-encode the content and render it to the page.
    You can pass any number of parameters to the InvokeAsync method. The name of the parameters (in this example,
    numberOfRecipes) is converted to kebab-case and exposed as a property in the view component’s Tag Helper
    (<number-of-recipes>). You can provide these parameters when you invoke the view component from a view. All view
    component parameters are required
    View components have access to the current request and HttpContext and the view() should use a partial view that exists
    in a Pages/Shared/Components/ComponentName/Default.cshtml.

    Packing and publishing a library to Nugget
    // Pack it using following command
    dotnet pack
    //Use dotnet-push-nuget tool to publish it (It needs some setup like user account)
    dotnet nuget push
    // The dotnet nuget push command pushes a package to the server and publishes it. The push command uses server and
    credential details found in the system's NuGet config file or chain of config files.







*@
